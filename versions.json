const { createCanvas, loadImage, registerFont } = require('canvas');
const { IMGBB } = global.utils;
const { getFlag, achs, achs_b } = global.helpers;
const fs = require('fs-extra');
const path = require('path');
const template = __dirname+"/canvas/status/template.png";
global.helpers.makeStatusProfile = Status;
const fontPath = path.join(__dirname, 'canvas', 'status', 'status.ttf');

registerFont(fontPath, { family: 'status' });
let deltaNext = 5;

const expToLevel = (exp, deltaNextLevel = deltaNext) => Math.floor((1 + Math.sqrt(1 + 8 * exp / deltaNextLevel)) / 2);

const levelToExp = (level, deltaNextLevel = deltaNext) => Math.floor(((Math.pow(level, 2) - level) * deltaNextLevel) / 2);

module.exports = {
  config: {
    name: "status",
    aliases: ["معلوماتي"],
    version: "1.0",
    author: "allou mohamed",
    countDown: 5,
    role: 0,
    shortDescription: {
      en: "status card.",
      ar: "رؤية بطاقة معلوماتك"
    },
    longDescription: {
      ar: "أمر يصمم لك صورة جميلة",
      en: "get status card that has some of your informations in bot"
    },
    category: "Canvas"
  },

  onStart: async function (MaTeam) {  
const { message, event, usersData, threadsData, args, role } = MaTeam;
  if (args[0] && !args[0].startsWith("@")) {
      switch(args[0].toLowerCase()) {
             case "setname":
             case "name":
             case "setn":
             const newname = args?.slice(1)?.join(" ")?.trim();

             if (!newname || newname.length > 14) return message.reply("add name < 14 letters");
              await usersData.set(event.senderID, newname, "name");
              await Status(MaTeam, "your status name changed and here is the preview:");
             break;
             case "setavt":
             case "avt":
             case "صورةالملف":
              if (args[1] == "rm") {
                 await usersData.set(event.senderID, false, "data.status_avt");
                 return await Status(MaTeam, "Seted default avatar and here the preview:");
             }
             const avt = event.messageReply?.attachments?.[0]?.url;
              if (!avt) return message.reply("Reply to a image");
              const upload = await IMGBB(avt);
              if (!upload) return message.reply("Unsupported image");
              await usersData.set(event.senderID, upload, "data.status_avt");
              await Status(MaTeam, "Your status profile changed successfully and see here the preview:", event.senderID);
             break;
             case "setcov":
             case "cov":
             case "cover":
             case "setcover":
              if (args[1] == "rm") {
                 await usersData.set(event.senderID, false, "data.status_cov");
                 return await Status(MaTeam, "Seted default cover and here is the preview.");
             }
             const cov = event.messageReply?.attachments?.[0]?.url;
              if (!cov) return message.reply("Reply to a image");
              const upload_cov = await IMGBB(cov);
              if (!upload_cov) return message.reply("Unsupported image");
              await usersData.set(event.senderID, upload_cov, "data.status_cov");
              await Status(MaTeam, "Your status cover changed successfully and here is the preview.", event.senderID);
             break;
             case "flag":
             case "setflag":
             case "fg":
             case "علم":
             if (args[1] == "rm") {
                 await usersData.set(event.senderID, false, "data.status_flag");
                 return await Status(MaTeam, "Seted default flag and here is preview:");
             }
             const flag_ = args[1]?.trim()?.toLowerCase();
             const fg = await getFlag(flag_);
             if (!fg) return message.reply(`enter the correct flag name.`);
              await usersData.set(event.senderID, fg, "data.status_flag");
             return await Status(MaTeam, `seted the ${flag_} as your status flag`);
             break;
              case "ach":
              case "achievement":
              if (args[1] == "rm") {
                 await usersData.set(event.senderID, false, "data.status_ach");
                 return message.reply("Removed the ach from your status profile.");
             }
             const ach_ = args[1]?.trim()?.toLowerCase();
              if (!ach_) {
                  
              await usersData.set(event.senderID, true, "data.status_ach");
             return await Status(MaTeam, "Seted default achievement and here is preview:");
              }
              if (ach_ == "bot_admin" && role < 2) return message.reply("U can't set this premium ach");
             if (!achs[ach_]) return message.reply(`Exsiting achs:\n${Object.keys(achs).join(", ")}`);
              await usersData.set(event.senderID, achs[ach_], "data.status_ach");
             return await Status(MaTeam, `Seted the ${ach_} as your status ach and here is the preview:`);
             break;
             case "icon":
             if (args[1] == "rm") {
                 await usersData.set(event.senderID, achs_b["facebook"], "data.status_icon");
                 return await Status(MaTeam, "Seted as default and here is preview:");
             }
             const icon_ = args[1]?.trim();
             
             if (!achs_b[icon_]) return message.reply(`Exsiting icons:\n${Object.keys(achs_b).join(", ")}`);
              await usersData.set(event.senderID, achs_b[icon_], "data.status_icon");
             return await Status(MaTeam, `Seted the ${icon_} as your status icon and here is preview:`);
             break;
              
             default:
             message.reply("💟 only use:\n/status setavt: to change Avatar.\n/status setcov: to change the cover.\n/status setname <new name>: set new name.\n/status ach <new ach>: set achievement.\n/status seticon <new icon>: set new icon.\n/status args[0] rm: remove something or reset to default.");
             break;
             };
  } else {
      await Status(MaTeam);
    }
  }
};

async function Status(MaTeam, settingsFeedBack, s_id) {
    
let default_profile = __dirname+"/canvas/status/avatar.jpeg";
let default_flag = __dirname+"/canvas/status/default_flag.jpg";
let default_cover = __dirname+"/canvas/status/background.jpeg";
let default_ach = __dirname+"/canvas/status/default_ach.png";
let default_ico = achs_b.facebook;
    
  const { message, event, usersData, threadsData, args, role } = MaTeam;
  let form = {};
  if (settingsFeedBack) form.body = settingsFeedBack;
  const all = await usersData.getAll();
  
  let id = Object.keys(event?.mentions || {})[0] || event?.messageReply?.senderID || event.senderID;
   if (s_id) id = s_id;
  //exp calc
  	const { exp } = await usersData.get(id);
	const levelUser = expToLevel(exp, deltaNext);
	const expNextLevel = levelToExp(levelUser + 1, deltaNext) - levelToExp(levelUser, deltaNext);
     
    const currentExp = expNextLevel - (levelToExp(levelUser + 1, deltaNext) - exp);
    
  const ID = ID_(id, all);
  const canvas = createCanvas(1300, 1000);
  const ctx = canvas.getContext("2d");
  const name_ = await usersData.getName(id);
  const name = name_?.trim() || "YukiUser";
  const avt = await usersData.get(id, "data.status_avt") || await usersData.getAvatarUrl(id);
  const cov = await usersData.get(id, "data.status_cov");
  
  if (avt) default_profile = avt;
  if (cov) default_cover = cov;
  const good_name = /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FFA-Za-z0-9 .,?!'"()\-@#]+$/;
  if (!good_name.test(name) || !name || name.length > 14){ if (!settingsFeedBack) form.body = "/status setname <new name> to set a name";}
  const bg = await loadImage(template);
  ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
  await drawCover(ctx, default_cover, 0, 0, 1300, 547);

  await drawCircularImage(ctx, default_profile, 220, 500, 340);
      //draw flag
      const flg = await usersData.get(id, "data.status_flag");
      if (flg) default_flag = flg;
      const flag = await loadImage(default_flag);
      const x = 450;
      const y = 435;
      const width = 60;
      const height = 35;
      const cornerRadius = 6;

      const reducedWidth = width * 0.8;
      const reducedHeight = height * 0.8;

      const offsetX = x + (width - reducedWidth) / 2;
      const offsetY = y + (height - reducedHeight) / 2;
      ctx.save();

      ctx.beginPath();
      ctx.moveTo(offsetX + cornerRadius, offsetY);
      ctx.arcTo(offsetX + reducedWidth, offsetY, offsetX + reducedWidth, offsetY + reducedHeight, cornerRadius);
      ctx.arcTo(offsetX + reducedWidth, offsetY + reducedHeight, offsetX, offsetY + reducedHeight, cornerRadius);
      ctx.arcTo(offsetX, offsetY + reducedHeight, offsetX, offsetY, cornerRadius);
      ctx.arcTo(offsetX, offsetY, offsetX + reducedWidth, offsetY, cornerRadius);
ctx.closePath();

      ctx.clip();

      ctx.drawImage(flag, offsetX, offsetY, reducedWidth, reducedHeight);

      ctx.restore();
      //ach
  const cs_ach = await usersData.get(id, "data.status_ach");
  if (typeof cs_ach == "string") default_ach = cs_ach;
  if (cs_ach != false) {
  const ach = await loadImage(default_ach);
  
  const as_ach = 600 / 150;if(300/as_ach<=50){d = 300;c=300/as_ach;}else{c=50;d=50*as_ach;}ctx.drawImage(ach, 150, 700, d, c);
      //icon
  const ico = await usersData.get(id, "data.status_icon");
  if (ico) default_ico = ico;
  const icon = await loadImage(default_ico);
      
  const as_ach_ = 50 / 50;if(50/as_ach_<=50){a=50;b=50/as_ach_;}else{b=50;a=50*as_ach_;}
      if (ico != false) {
ctx.drawImage(icon, 80, 700, a, b);
          }
  }
      //slider bar
  await drawSliderBar(ctx, '#00F4FF', '#3fea95', currentExp, expNextLevel, 570, 650, 640, 10);
      //trust factor 
  await drawTrustFactor(ctx, "80/100");
      //name
  ctx.filter = 'none'; 
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = 'white';
  ctx.font = 'bold 50px status';
  ctx.fillText(name, 450, 520);
     //level
  ctx.globalAlpha = 1;
  ctx.fillStyle = 'white';
  ctx.font = 'bold 36px status';
  ctx.fillText(`Level ${levelUser}`, 570, 640);
     //points exp
  ctx.globalAlpha = 0.6;
  ctx.fillStyle = 'white';
  ctx.font = '25px status';
  ctx.fillText(`${currentExp} Experience point`, 570, 690);
     //ID_
 
  ctx.font = '50px status';
  ctx.globalAlpha = 0.6;
  const idText = `#${ID}`;
  const idTextWidth = ctx.measureText(idText).width;
  ctx.fillText(idText, 1200 - idTextWidth/2, 520);
  ctx.globalAlpha = 1;
     //count
    const tiddata = await threadsData.get(event.threadID);
    const members = tiddata.members;
    const fin = members.find(user => user.userID == id);
    const count = fin?.count || 0;
    
    ctx.font = '30px status';
    const chatText = `${count}`;
    const chatTextWidth = ctx.measureText(chatText).width;
    ctx.fillText(chatText, 840 - chatTextWidth/2, 810);
     //money
  const money = await usersData.getMoney(id);
  ctx.fillStyle = 'white';
  const mnText = String(money.toFixed(2));
  const mnTextWidth = ctx.measureText(mnText).width;
  ctx.fillText(mnText, 580 - mnTextWidth/2, 810);
     //global ranking
	all.sort((a, b) => b.exp - a.exp);
      const rank = all.findIndex(user => user.userID == id) + 1;
      
      const rText = `${rank}`;
      const rTextWidth = ctx.measureText(rText).width;
      ctx.fillText(rText, 1120 - rTextWidth/2, 810);
    //other draws:-:
    //Points
    const Points = await usersData.getPoints(id);
  ctx.font = '25px status';
  const ptText = `${Points}`;
  const ptTextWidth = ctx.measureText(ptText).width;
  ctx.fillText(ptText, 780 - ptTextWidth/2, 896);
  // soon but now NONE
    
  const nnText = "NONE";
  const nnTextWidth = ctx.measureText(nnText).width;
  ctx.fillText(nnText, 590 - nnTextWidth/2, 896);
  ctx.fillText(nnText, 980 - nnTextWidth/2, 896);    
  ctx.fillText(nnText, 1170 - nnTextWidth/2, 896);
    //send image:-:
  const outputFilePath = __dirname + "/cache/" + event.senderID + "-status.png";
  const out = fs.createWriteStream(outputFilePath);

  out.on("finish", async () => {
    
    const stream = fs.createReadStream(outputFilePath);
    form.attachment = stream;
    message.reply(form);
  });

  const stream = canvas.createPNGStream();
  stream.pipe(out);
      }
  
function ID_(userID, userDataArray) {
  const sortedData = userDataArray.sort((a, b) =>
    new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
  );

  const userIndex = sortedData.findIndex(user => user.userID === userID);
  if (userIndex !== -1) {
  
    return userIndex + 1;
  } else {
    return "Last"; 
  }
}

function drawSliderBar(ctx, colorA, colorB, currentExp, expNextLevel, x, y, width, height) {
    const MAX_WIDTH = 640;
    const scaleFactor = Math.min(MAX_WIDTH / width, 1);
    const scaledWidth = Math.min(width, MAX_WIDTH);
    const scaledExpNextLevel = expNextLevel * (scaledWidth / width);
    const scaledCurrentExp = currentExp * (scaledWidth / width);
    const percentage = Math.min((scaledCurrentExp / scaledExpNextLevel) * 100, 100);

    const gradient = ctx.createLinearGradient(x, y, x + scaledWidth, y);
    gradient.addColorStop(0, colorA);
    gradient.addColorStop(1, colorB);

    ctx.fillStyle = '#2f302f';
    ctx.fillRect(x, y, scaledWidth, height);

    ctx.fillStyle = gradient;
    ctx.fillRect(x, y, scaledWidth * (percentage / 100), height);
}

async function drawCircularImage(ctx, imagePath, x, y, size) {
    const avatar = await loadImage(imagePath);
    const imageWidth = avatar.width;
    const imageHeight = avatar.height;

    const squareSize = Math.min(imageWidth, imageHeight);
    const radius = size / 2;

    const startX = (imageWidth - squareSize) / 2;
    const startY = (imageHeight - squareSize) / 2;

    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.clip();

    ctx.drawImage(
        avatar,
        startX, startY, squareSize, squareSize,
        x - radius, y - radius, size, size     
    );

    ctx.lineWidth = 15;
    ctx.strokeStyle = 'black';
    ctx.stroke();

    ctx.restore();
}


async function drawCover(ctx, inputImagePath, x, y, coverWidth, coverHeight) {
  try {
    const image = await loadImage(inputImagePath);
    const targetBgWidth = 1300;
    const targetBgHeight = 547;
    const imageAspect = image.width / image.height; 
    const targetAspect = targetBgWidth / targetBgHeight; 

    let sourceX, sourceY, sourceWidth, sourceHeight;

    if (imageAspect > targetAspect) {
      sourceWidth = image.height * targetAspect;
      sourceHeight = image.height;
      sourceX = (image.width - sourceWidth) / 2;
      sourceY = 0;
    } else {
      sourceWidth = image.width;
      sourceHeight = image.width / targetAspect;
      sourceX = 0;
      sourceY = (image.height - sourceHeight) / 2;
    }

    const canvas = createCanvas(targetBgWidth, targetBgHeight);
    const tempCtx = canvas.getContext('2d');
    
    tempCtx.drawImage(
      image,
      sourceX,
      sourceY,
      sourceWidth,
      sourceHeight,
      0,
      0,
      targetBgWidth,
      targetBgHeight
    );

    ctx.drawImage(
      canvas,
      0, 0, targetBgWidth, targetBgHeight,
      x, y, coverWidth, coverHeight
    );
  } catch (err) {
    console.error('Error drawing cover:', err);
  }
}

function drawTrustFactor(ctx, data) {
    ctx.fillStyle = '#2f302f';
    ctx.fillRect(80, 760, 280, 45);
    ctx.font = 'bold 20px status';
    ctx.fillStyle = "white";
    ctx.globalAlpha = 0.8;
    const tText = "Trust Factor";
    const tTextWidth = ctx.measureText(tText).width;
    ctx.fillText(tText, 220 - tTextWidth/2, 790);
    ctx.globalAlpha = 1;
    const sliderX = 80;
const sliderY = 800;
const sliderWidth = 280;
const sliderHeight = 5;

    //const data = "50/100"; 
const [value, max] = data.split('/').map(Number);
const handleRadius = 7;

const filledWidth = (value / max) * sliderWidth;
const handleX = sliderX + filledWidth;
const handleY = sliderY + (sliderHeight / 2);

ctx.fillStyle = '#FF0000'; 
ctx.fillRect(sliderX, sliderY, sliderWidth, sliderHeight);

ctx.fillStyle = '#00FF00'; 
ctx.fillRect(sliderX, sliderY, filledWidth, sliderHeight);
/*
ctx.fillStyle = '#FFFFFF'; 
ctx.beginPath();
ctx.arc(handleX, handleY, handleRadius, 0, 2 * Math.PI);
ctx.fill();*/
}

